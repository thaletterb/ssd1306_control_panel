   1               		.file	"twimaster.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  73               	.global	i2c_init
  75               	i2c_init:
  76               		.stabd	46,0,0
   1:twimaster.c   **** /*************************************************************************
   2:twimaster.c   **** * Title:    I2C master library using hardware TWI interface
   3:twimaster.c   **** * Author:   Peter Fleury <pfleury@gmx.ch>  http://jump.to/fleury
   4:twimaster.c   **** * File:     $Id: twimaster.c,v 1.3 2005/07/02 11:14:21 Peter Exp $
   5:twimaster.c   **** * Software: AVR-GCC 3.4.3 / avr-libc 1.2.3
   6:twimaster.c   **** * Target:   any AVR device with hardware TWI 
   7:twimaster.c   **** * Usage:    API compatible with I2C Software Library i2cmaster.h
   8:twimaster.c   **** **************************************************************************/
   9:twimaster.c   **** #include <inttypes.h>
  10:twimaster.c   **** #include <compat/twi.h>
  11:twimaster.c   **** 
  12:twimaster.c   **** #include <i2cmaster.h>
  13:twimaster.c   **** 
  14:twimaster.c   **** 
  15:twimaster.c   **** /* define CPU frequency in Mhz here if not defined in Makefile */
  16:twimaster.c   **** #ifndef F_CPU
  17:twimaster.c   **** #define F_CPU 4000000UL
  18:twimaster.c   **** #endif
  19:twimaster.c   **** 
  20:twimaster.c   **** /* I2C clock in Hz */
  21:twimaster.c   **** #define SCL_CLOCK  100000L
  22:twimaster.c   **** 
  23:twimaster.c   **** 
  24:twimaster.c   **** /*************************************************************************
  25:twimaster.c   ****  Initialization of the I2C bus interface. Need to be called only once
  26:twimaster.c   **** *************************************************************************/
  27:twimaster.c   **** void i2c_init(void)
  28:twimaster.c   **** {
  78               	.LM0:
  79               	.LFBB1:
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 0 */
  83               	.L__stack_usage = 0
  29:twimaster.c   ****   /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  30:twimaster.c   ****   
  31:twimaster.c   ****   TWSR = 0;                         /* no prescaler */
  85               	.LM1:
  86 0000 1092 B900 		sts 185,__zero_reg__
  32:twimaster.c   ****   TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
  88               	.LM2:
  89 0004 80E2      		ldi r24,lo8(32)
  90 0006 8093 B800 		sts 184,r24
  91 000a 0895      		ret
  93               	.Lscope1:
  95               		.stabd	78,0,0
  98               	.global	i2c_start
 100               	i2c_start:
 101               		.stabd	46,0,0
  33:twimaster.c   **** 
  34:twimaster.c   **** }/* i2c_init */
  35:twimaster.c   **** 
  36:twimaster.c   **** 
  37:twimaster.c   **** /*************************************************************************	
  38:twimaster.c   ****   Issues a start condition and sends address and transfer direction.
  39:twimaster.c   ****   return 0 = device accessible, 1= failed to access device
  40:twimaster.c   **** *************************************************************************/
  41:twimaster.c   **** unsigned char i2c_start(unsigned char address)
  42:twimaster.c   **** {
 103               	.LM3:
 104               	.LFBB2:
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 0 */
 108               	.L__stack_usage = 0
  43:twimaster.c   ****     uint8_t   twst;
  44:twimaster.c   **** 
  45:twimaster.c   **** 	// send START condition
  46:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 110               	.LM4:
 111 000c 94EA      		ldi r25,lo8(-92)
 112 000e 9093 BC00 		sts 188,r25
 113               	.L3:
  47:twimaster.c   **** 
  48:twimaster.c   **** 	// wait until transmission completed
  49:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 115               	.LM5:
 116 0012 9091 BC00 		lds r25,188
 117 0016 97FF      		sbrs r25,7
 118 0018 00C0      		rjmp .L3
  50:twimaster.c   **** 
  51:twimaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits.
  52:twimaster.c   **** 	twst = TW_STATUS & 0xF8;
 120               	.LM6:
 121 001a 9091 B900 		lds r25,185
 122 001e 987F      		andi r25,lo8(-8)
  53:twimaster.c   **** 	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 124               	.LM7:
 125 0020 9830      		cpi r25,lo8(8)
 126 0022 01F0      		breq .L4
 128               	.LM8:
 129 0024 9031      		cpi r25,lo8(16)
 130 0026 01F0      		breq .L4
 131               	.L7:
 133               	.LM9:
 134 0028 81E0      		ldi r24,lo8(1)
 135 002a 0895      		ret
 136               	.L4:
  54:twimaster.c   **** 
  55:twimaster.c   **** 	// send device address
  56:twimaster.c   **** 	TWDR = address;
 138               	.LM10:
 139 002c 8093 BB00 		sts 187,r24
  57:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 141               	.LM11:
 142 0030 84E8      		ldi r24,lo8(-124)
 143 0032 8093 BC00 		sts 188,r24
 144               	.L6:
  58:twimaster.c   **** 
  59:twimaster.c   **** 	// wail until transmission completed and ACK/NACK has been received
  60:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 146               	.LM12:
 147 0036 8091 BC00 		lds r24,188
 148 003a 87FF      		sbrs r24,7
 149 003c 00C0      		rjmp .L6
  61:twimaster.c   **** 
  62:twimaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits.
  63:twimaster.c   **** 	twst = TW_STATUS & 0xF8;
 151               	.LM13:
 152 003e 8091 B900 		lds r24,185
 153 0042 887F      		andi r24,lo8(-8)
  64:twimaster.c   **** 	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 155               	.LM14:
 156 0044 8831      		cpi r24,lo8(24)
 157 0046 01F0      		breq .L8
 159               	.LM15:
 160 0048 8034      		cpi r24,lo8(64)
 161 004a 01F4      		brne .L7
 162               	.L8:
  65:twimaster.c   **** 
  66:twimaster.c   **** 	return 0;
 164               	.LM16:
 165 004c 80E0      		ldi r24,0
  67:twimaster.c   **** 
  68:twimaster.c   **** }/* i2c_start */
 167               	.LM17:
 168 004e 0895      		ret
 170               	.Lscope2:
 172               		.stabd	78,0,0
 175               	.global	i2c_start_wait
 177               	i2c_start_wait:
 178               		.stabd	46,0,0
  69:twimaster.c   **** 
  70:twimaster.c   **** 
  71:twimaster.c   **** /*************************************************************************
  72:twimaster.c   ****  Issues a start condition and sends address and transfer direction.
  73:twimaster.c   ****  If device is busy, use ack polling to wait until device is ready
  74:twimaster.c   ****  
  75:twimaster.c   ****  Input:   address and transfer direction of I2C device
  76:twimaster.c   **** *************************************************************************/
  77:twimaster.c   **** void i2c_start_wait(unsigned char address)
  78:twimaster.c   **** {
 180               	.LM18:
 181               	.LFBB3:
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 0 */
 185               	.L__stack_usage = 0
  79:twimaster.c   ****     uint8_t   twst;
  80:twimaster.c   **** 
  81:twimaster.c   **** 
  82:twimaster.c   ****     while ( 1 )
  83:twimaster.c   ****     {
  84:twimaster.c   **** 	    // send START condition
  85:twimaster.c   **** 	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 187               	.LM19:
 188 0050 24EA      		ldi r18,lo8(-92)
  86:twimaster.c   ****     
  87:twimaster.c   ****     	// wait until transmission completed
  88:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
  89:twimaster.c   ****     
  90:twimaster.c   ****     	// check value of TWI Status Register. Mask prescaler bits.
  91:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
  92:twimaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
  93:twimaster.c   ****     
  94:twimaster.c   ****     	// send device address
  95:twimaster.c   ****     	TWDR = address;
  96:twimaster.c   ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 190               	.LM20:
 191 0052 34E8      		ldi r19,lo8(-124)
  97:twimaster.c   ****     
  98:twimaster.c   ****     	// wail until transmission completed
  99:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
 100:twimaster.c   ****     
 101:twimaster.c   ****     	// check value of TWI Status Register. Mask prescaler bits.
 102:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
 103:twimaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 104:twimaster.c   ****     	{    	    
 105:twimaster.c   ****     	    /* device busy, send stop condition to terminate write operation */
 106:twimaster.c   **** 	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 193               	.LM21:
 194 0054 44E9      		ldi r20,lo8(-108)
 195               	.L37:
  85:twimaster.c   **** 	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 197               	.LM22:
 198 0056 2093 BC00 		sts 188,r18
 199               	.L18:
  88:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
 201               	.LM23:
 202 005a 9091 BC00 		lds r25,188
 203 005e 97FF      		sbrs r25,7
 204 0060 00C0      		rjmp .L18
  91:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
 206               	.LM24:
 207 0062 9091 B900 		lds r25,185
 208 0066 987F      		andi r25,lo8(-8)
  92:twimaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 210               	.LM25:
 211 0068 9830      		cpi r25,lo8(8)
 212 006a 01F0      		breq .L20
  92:twimaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 214               	.LM26:
 215 006c 9031      		cpi r25,lo8(16)
 216 006e 01F4      		brne .L37
 217               	.L20:
  95:twimaster.c   ****     	TWDR = address;
 219               	.LM27:
 220 0070 8093 BB00 		sts 187,r24
  96:twimaster.c   ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 222               	.LM28:
 223 0074 3093 BC00 		sts 188,r19
 224               	.L22:
  99:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
 226               	.LM29:
 227 0078 9091 BC00 		lds r25,188
 228 007c 97FF      		sbrs r25,7
 229 007e 00C0      		rjmp .L22
 102:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
 231               	.LM30:
 232 0080 9091 B900 		lds r25,185
 233 0084 987F      		andi r25,lo8(-8)
 103:twimaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 235               	.LM31:
 236 0086 9032      		cpi r25,lo8(32)
 237 0088 01F0      		breq .L23
 103:twimaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 239               	.LM32:
 240 008a 9835      		cpi r25,lo8(88)
 241 008c 01F4      		brne .L17
 242               	.L23:
 244               	.LM33:
 245 008e 4093 BC00 		sts 188,r20
 246               	.L25:
 107:twimaster.c   **** 	        
 108:twimaster.c   **** 	        // wait until stop condition is executed and bus released
 109:twimaster.c   **** 	        while(TWCR & (1<<TWSTO));
 248               	.LM34:
 249 0092 9091 BC00 		lds r25,188
 250 0096 94FD      		sbrc r25,4
 251 0098 00C0      		rjmp .L25
 252 009a 00C0      		rjmp .L37
 253               	.L17:
 254 009c 0895      		ret
 256               	.Lscope3:
 258               		.stabd	78,0,0
 261               	.global	i2c_rep_start
 263               	i2c_rep_start:
 264               		.stabd	46,0,0
 110:twimaster.c   **** 	        
 111:twimaster.c   ****     	    continue;
 112:twimaster.c   ****     	}
 113:twimaster.c   ****     	//if( twst != TW_MT_SLA_ACK) return 1;
 114:twimaster.c   ****     	break;
 115:twimaster.c   ****      }
 116:twimaster.c   **** 
 117:twimaster.c   **** }/* i2c_start_wait */
 118:twimaster.c   **** 
 119:twimaster.c   **** 
 120:twimaster.c   **** /*************************************************************************
 121:twimaster.c   ****  Issues a repeated start condition and sends address and transfer direction 
 122:twimaster.c   **** 
 123:twimaster.c   ****  Input:   address and transfer direction of I2C device
 124:twimaster.c   ****  
 125:twimaster.c   ****  Return:  0 device accessible
 126:twimaster.c   ****           1 failed to access device
 127:twimaster.c   **** *************************************************************************/
 128:twimaster.c   **** unsigned char i2c_rep_start(unsigned char address)
 129:twimaster.c   **** {
 266               	.LM35:
 267               	.LFBB4:
 268               	/* prologue: function */
 269               	/* frame size = 0 */
 270               	/* stack size = 0 */
 271               	.L__stack_usage = 0
 130:twimaster.c   ****     return i2c_start( address );
 273               	.LM36:
 274 009e 0C94 0000 		jmp i2c_start
 276               	.Lscope4:
 278               		.stabd	78,0,0
 280               	.global	i2c_stop
 282               	i2c_stop:
 283               		.stabd	46,0,0
 131:twimaster.c   **** 
 132:twimaster.c   **** }/* i2c_rep_start */
 133:twimaster.c   **** 
 134:twimaster.c   **** 
 135:twimaster.c   **** /*************************************************************************
 136:twimaster.c   ****  Terminates the data transfer and releases the I2C bus
 137:twimaster.c   **** *************************************************************************/
 138:twimaster.c   **** void i2c_stop(void)
 139:twimaster.c   **** {
 285               	.LM37:
 286               	.LFBB5:
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 0 */
 290               	.L__stack_usage = 0
 140:twimaster.c   ****     /* send stop condition */
 141:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 292               	.LM38:
 293 00a2 84E9      		ldi r24,lo8(-108)
 294 00a4 8093 BC00 		sts 188,r24
 295               	.L40:
 142:twimaster.c   **** 	
 143:twimaster.c   **** 	// wait until stop condition is executed and bus released
 144:twimaster.c   **** 	while(TWCR & (1<<TWSTO)); //SSD1306 is cheap and doesn't acknowledge a stop condition
 297               	.LM39:
 298 00a8 8091 BC00 		lds r24,188
 299 00ac 84FD      		sbrc r24,4
 300 00ae 00C0      		rjmp .L40
 301               	/* epilogue start */
 145:twimaster.c   **** 
 146:twimaster.c   **** }/* i2c_stop */
 303               	.LM40:
 304 00b0 0895      		ret
 306               	.Lscope5:
 308               		.stabd	78,0,0
 311               	.global	i2c_write
 313               	i2c_write:
 314               		.stabd	46,0,0
 147:twimaster.c   **** 
 148:twimaster.c   **** 
 149:twimaster.c   **** /*************************************************************************
 150:twimaster.c   ****   Send one byte to I2C device
 151:twimaster.c   ****   
 152:twimaster.c   ****   Input:    byte to be transfered
 153:twimaster.c   ****   Return:   0 write successful 
 154:twimaster.c   ****             1 write failed
 155:twimaster.c   **** *************************************************************************/
 156:twimaster.c   **** unsigned char i2c_write( unsigned char data )
 157:twimaster.c   **** {	
 316               	.LM41:
 317               	.LFBB6:
 318               	/* prologue: function */
 319               	/* frame size = 0 */
 320               	/* stack size = 0 */
 321               	.L__stack_usage = 0
 158:twimaster.c   ****     uint8_t   twst;
 159:twimaster.c   ****     
 160:twimaster.c   **** 	// send data to the previously addressed device
 161:twimaster.c   **** 	TWDR = data;
 323               	.LM42:
 324 00b2 8093 BB00 		sts 187,r24
 162:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 326               	.LM43:
 327 00b6 84E8      		ldi r24,lo8(-124)
 328 00b8 8093 BC00 		sts 188,r24
 329               	.L43:
 163:twimaster.c   **** 
 164:twimaster.c   **** 	// wait until transmission completed
 165:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 331               	.LM44:
 332 00bc 8091 BC00 		lds r24,188
 333 00c0 87FF      		sbrs r24,7
 334 00c2 00C0      		rjmp .L43
 166:twimaster.c   **** 
 167:twimaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits
 168:twimaster.c   **** 	twst = TW_STATUS & 0xF8;
 336               	.LM45:
 337 00c4 9091 B900 		lds r25,185
 338 00c8 987F      		andi r25,lo8(-8)
 169:twimaster.c   **** 	if( twst != TW_MT_DATA_ACK) return 1;
 340               	.LM46:
 341 00ca 81E0      		ldi r24,lo8(1)
 342 00cc 9832      		cpi r25,lo8(40)
 343 00ce 01F4      		brne .L44
 344 00d0 80E0      		ldi r24,0
 345               	.L44:
 170:twimaster.c   **** 	return 0;
 171:twimaster.c   **** 
 172:twimaster.c   **** }/* i2c_write */
 347               	.LM47:
 348 00d2 0895      		ret
 350               	.Lscope6:
 352               		.stabd	78,0,0
 354               	.global	i2c_readAck
 356               	i2c_readAck:
 357               		.stabd	46,0,0
 173:twimaster.c   **** 
 174:twimaster.c   **** 
 175:twimaster.c   **** /*************************************************************************
 176:twimaster.c   ****  Read one byte from the I2C device, request more data from device 
 177:twimaster.c   ****  
 178:twimaster.c   ****  Return:  byte read from I2C device
 179:twimaster.c   **** *************************************************************************/
 180:twimaster.c   **** unsigned char i2c_readAck(void)
 181:twimaster.c   **** {
 359               	.LM48:
 360               	.LFBB7:
 361               	/* prologue: function */
 362               	/* frame size = 0 */
 363               	/* stack size = 0 */
 364               	.L__stack_usage = 0
 182:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 366               	.LM49:
 367 00d4 84EC      		ldi r24,lo8(-60)
 368 00d6 8093 BC00 		sts 188,r24
 369               	.L47:
 183:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));    
 371               	.LM50:
 372 00da 8091 BC00 		lds r24,188
 373 00de 87FF      		sbrs r24,7
 374 00e0 00C0      		rjmp .L47
 184:twimaster.c   **** 
 185:twimaster.c   ****     return TWDR;
 376               	.LM51:
 377 00e2 8091 BB00 		lds r24,187
 186:twimaster.c   **** 
 187:twimaster.c   **** }/* i2c_readAck */
 379               	.LM52:
 380 00e6 0895      		ret
 382               	.Lscope7:
 384               		.stabd	78,0,0
 386               	.global	i2c_readNak
 388               	i2c_readNak:
 389               		.stabd	46,0,0
 188:twimaster.c   **** 
 189:twimaster.c   **** 
 190:twimaster.c   **** /*************************************************************************
 191:twimaster.c   ****  Read one byte from the I2C device, read is followed by a stop condition 
 192:twimaster.c   ****  
 193:twimaster.c   ****  Return:  byte read from I2C device
 194:twimaster.c   **** *************************************************************************/
 195:twimaster.c   **** unsigned char i2c_readNak(void)
 196:twimaster.c   **** {
 391               	.LM53:
 392               	.LFBB8:
 393               	/* prologue: function */
 394               	/* frame size = 0 */
 395               	/* stack size = 0 */
 396               	.L__stack_usage = 0
 197:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 398               	.LM54:
 399 00e8 84E8      		ldi r24,lo8(-124)
 400 00ea 8093 BC00 		sts 188,r24
 401               	.L50:
 198:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 403               	.LM55:
 404 00ee 8091 BC00 		lds r24,188
 405 00f2 87FF      		sbrs r24,7
 406 00f4 00C0      		rjmp .L50
 199:twimaster.c   **** 	
 200:twimaster.c   ****     return TWDR;
 408               	.LM56:
 409 00f6 8091 BB00 		lds r24,187
 201:twimaster.c   **** 
 202:twimaster.c   **** }/* i2c_readNak */
 411               	.LM57:
 412 00fa 0895      		ret
 414               	.Lscope8:
 416               		.stabd	78,0,0
 418               	.Letext0:
 419               		.ident	"GCC: (GNU) 4.7.2"
DEFINED SYMBOLS
                            *ABS*:00000000 twimaster.c
     /tmp/ccGw9Xpb.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccGw9Xpb.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccGw9Xpb.s:4      *ABS*:0000003f __SREG__
     /tmp/ccGw9Xpb.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccGw9Xpb.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccGw9Xpb.s:75     .text:00000000 i2c_init
     /tmp/ccGw9Xpb.s:100    .text:0000000c i2c_start
     /tmp/ccGw9Xpb.s:177    .text:00000050 i2c_start_wait
     /tmp/ccGw9Xpb.s:263    .text:0000009e i2c_rep_start
     /tmp/ccGw9Xpb.s:282    .text:000000a2 i2c_stop
     /tmp/ccGw9Xpb.s:313    .text:000000b2 i2c_write
     /tmp/ccGw9Xpb.s:356    .text:000000d4 i2c_readAck
     /tmp/ccGw9Xpb.s:388    .text:000000e8 i2c_readNak

NO UNDEFINED SYMBOLS
